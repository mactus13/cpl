//===-- CplISelDAGToDAG.cpp - A dag to dag inst selector for Cpl ----------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the Cpl target.
//
//===----------------------------------------------------------------------===//

#include "Cpl.h"
#include "CplISelLowering.h"
#include "CplTargetMachine.h"

#include "llvm/ADT/DenseMap.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/IR/Intrinsics.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Support/Compiler.h"
#include "llvm/Support/Debug.h"
using namespace llvm;

#define DEBUG_TYPE "Cpl-isel"

//===----------------------------------------------------------------------===//
// Instruction Selector Implementation
//===----------------------------------------------------------------------===//

namespace llvm {
  void initializeCplDAGToDAGISelPass(PassRegistry&);
}

//===--------------------------------------------------------------------===//
/// CplDAGToDAGISel - Cpl specific code to select Cpl machine
/// instructions for SelectionDAG operations.
///
namespace {
class CplDAGToDAGISel : public SelectionDAGISel {
  /// Subtarget - Keep a pointer to the Cpl Subtarget around so that we can
  /// make the right decision when generating code for different targets.
  const CplSubtarget &Subtarget;

  // Keep a reference to CplTargetMachine.
  const CplTargetMachine& TM;
  DenseMap<const GlobalValue *, unsigned> GlobalAddressUseCountMap;
public:
  explicit CplDAGToDAGISel(CplTargetMachine &targetmachine,
                               CodeGenOpt::Level OptLevel)
    : SelectionDAGISel(targetmachine, OptLevel),
      Subtarget(targetmachine.getSubtarget<CplSubtarget>()),
      TM(targetmachine) {
    initializeCplDAGToDAGISelPass(*PassRegistry::getPassRegistry());
  }

  bool SelectAddr(SDNode *Parent, SDValue Addr, SDValue &Base, SDValue &Off);

  SDNode *Select(SDNode *N) override;

  const char *getPassName() const override {
    return "Cpl DAG->DAG Pattern Instruction Selection";
  }

// Include the pieces autogenerated from the target description.
#include "CplGenDAGISel.inc"
};
}  // end anonymous namespace


/// createCplISelDag - This pass converts a legalized DAG into a
/// Cpl-specific DAG, ready for instruction scheduling.
///
FunctionPass *llvm::createCplISelDag(CplTargetMachine &TM,
                                         CodeGenOpt::Level OptLevel) {
  return new CplDAGToDAGISel(TM, OptLevel);
}

static void initializePassOnce(PassRegistry &Registry) {
  const char *Name = "Cpl DAG->DAG Pattern Instruction Selection";
  PassInfo *PI = new PassInfo(Name, "Cpl-isel",
                              &SelectionDAGISel::ID, nullptr, false, false);
  Registry.registerPass(*PI, true);
}

void llvm::initializeCplDAGToDAGISelPass(PassRegistry &Registry) {
  CALL_ONCE_INITIALIZATION(initializePassOnce)
}

bool CplDAGToDAGISel::SelectAddr(SDNode *Parent, SDValue Addr, SDValue &Base,
  SDValue &Off) {
  EVT ValTy = Addr.getValueType();

  // if Address is FI, get the TargetFrameIndex.
  if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
    Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), ValTy);
    Off = CurDAG->getTargetConstant(0, ValTy);
    return true;
  }

  return false;
}

SDNode *CplDAGToDAGISel::Select(SDNode *N) {
  if (N->isMachineOpcode()) {
    N->setNodeId(-1);
    return nullptr;   // Already selected.
  }

  if (N->getOpcode() == CplISD::MOVi32) {
    SDLoc DL(N);
    ConstantSDNode *Op0 = dyn_cast<ConstantSDNode>(N->getOperand(0));
    return CurDAG->getMachineNode(Cpl::MOV_I32, DL, MVT::i32, CurDAG->getTargetConstant(Op0->getSExtValue(), MVT::i32));
  }

  return SelectCode(N);
}
